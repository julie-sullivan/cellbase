<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JsonStringAnnotatorTask.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">cellbase-app</a> &gt; <a href="index.source.html" class="el_package">org.opencb.cellbase.app.cli.variant.annotation</a> &gt; <span class="el_source">JsonStringAnnotatorTask.java</span></div><h1>JsonStringAnnotatorTask.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2015 OpenCB
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.opencb.cellbase.app.cli.variant.annotation;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.databind.MapperFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.mortbay.util.ajax.JSON;
import org.opencb.biodata.models.variant.Variant;
import org.opencb.biodata.tools.variant.VariantNormalizer;
import org.opencb.biodata.models.variant.avro.VariantAvro;
import org.opencb.cellbase.core.variant.annotation.VariantAnnotator;
import org.opencb.commons.run.ParallelTaskRunner;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * Created by fjlopez on 02/03/15.
 */
@Deprecated
public class JsonStringAnnotatorTask implements ParallelTaskRunner.TaskWithException&lt;String, Variant, Exception&gt; {

<span class="nc" id="L41">    private final Logger logger = LoggerFactory.getLogger(this.getClass());</span>
    private List&lt;VariantAnnotator&gt; variantAnnotatorList;
    private boolean normalize;
    private static ObjectMapper jsonObjectMapper;
    private VariantNormalizer normalizer;

    static {
<span class="nc" id="L48">        jsonObjectMapper = new ObjectMapper();</span>
<span class="nc" id="L49">        jsonObjectMapper.configure(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS, true);</span>
<span class="nc" id="L50">        jsonObjectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);</span>
<span class="nc" id="L51">    }</span>

    private static final String VARIANT_STRING_PATTERN = &quot;([ACGTN]*)|(&lt;CNV[0-9]+&gt;)|(&lt;DUP&gt;)|(&lt;DEL&gt;)|(&lt;INS&gt;)|(&lt;INV&gt;)&quot;;

    public JsonStringAnnotatorTask(List&lt;VariantAnnotator&gt; variantAnnotatorList) {
<span class="nc" id="L56">        this(variantAnnotatorList, true, new VariantNormalizer.VariantNormalizerConfig());</span>
<span class="nc" id="L57">    }</span>

    public JsonStringAnnotatorTask(List&lt;VariantAnnotator&gt; variantAnnotatorList, boolean normalize,
<span class="nc" id="L60">                                   VariantNormalizer.VariantNormalizerConfig variantNormalizerConfig) {</span>
<span class="nc" id="L61">        this.variantAnnotatorList = variantAnnotatorList;</span>
<span class="nc" id="L62">        this.normalize = normalize;</span>
        //normalizer = new VariantNormalizer(true, false, decompose);
<span class="nc" id="L64">        normalizer = new VariantNormalizer(variantNormalizerConfig);</span>
<span class="nc" id="L65">    }</span>

    public void pre() {
<span class="nc bnc" id="L68" title="All 2 branches missed.">        for (VariantAnnotator variantAnnotator : variantAnnotatorList) {</span>
<span class="nc" id="L69">            variantAnnotator.open();</span>
<span class="nc" id="L70">        }</span>
<span class="nc" id="L71">    }</span>

    public List&lt;Variant&gt; apply(List&lt;String&gt; batch) throws Exception {
<span class="nc" id="L74">        List&lt;Variant&gt; variantList = parseVariantList(batch);</span>
        List&lt;Variant&gt; normalizedVariantList;
<span class="nc bnc" id="L76" title="All 2 branches missed.">        if (normalize) {</span>
<span class="nc" id="L77">            normalizedVariantList = new ArrayList&lt;&gt;(variantList.size());</span>
<span class="nc bnc" id="L78" title="All 2 branches missed.">            for (Variant variant : variantList) {</span>
                try {
<span class="nc" id="L80">                    normalizedVariantList.addAll(normalizer.apply(Collections.singletonList(variant)));</span>
<span class="nc" id="L81">                } catch (RuntimeException e) {</span>
<span class="nc" id="L82">                    logger.warn(&quot;Error found during variant normalization. Variant: {}&quot;, variant.toString());</span>
<span class="nc" id="L83">                    logger.warn(&quot;This variant will be skipped and annotation will continue&quot;);</span>
<span class="nc" id="L84">                    logger.warn(&quot;Full stack trace below&quot;, e);</span>
<span class="nc" id="L85">                }</span>
<span class="nc" id="L86">            }</span>
        } else {
<span class="nc" id="L88">            normalizedVariantList = variantList;</span>
        }
<span class="nc bnc" id="L90" title="All 2 branches missed.">        for (VariantAnnotator variantAnnotator : variantAnnotatorList) {</span>
<span class="nc" id="L91">            variantAnnotator.run(normalizedVariantList);</span>
<span class="nc" id="L92">        }</span>
<span class="nc" id="L93">        return normalizedVariantList;</span>
    }

    private List&lt;Variant&gt; parseVariantList(List&lt;String&gt; batch) {
<span class="nc" id="L97">        List&lt;Variant&gt; variantList = new ArrayList&lt;&gt;(batch.size());</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">        for (String line : batch) {</span>
<span class="nc bnc" id="L99" title="All 4 branches missed.">            if (line.startsWith(&quot;#&quot;) || line.trim().isEmpty()) {</span>
<span class="nc" id="L100">                continue;</span>
            }
<span class="nc" id="L102">            Variant variant = new Variant(jsonObjectMapper.convertValue(JSON.parse(line), VariantAvro.class));</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">            if (isValid(variant)) {</span>
                // Read variants may not have the variant type set and this might cause NPE
<span class="nc bnc" id="L105" title="All 2 branches missed.">                if (variant.getType() == null) {</span>
<span class="nc" id="L106">                    variant.setType(variant.inferType(variant.getReference(), variant.getAlternate()));</span>
<span class="nc" id="L107">                    variant.resetLength();</span>
                }
<span class="nc" id="L109">                variantList.add(variant);</span>
            } else {
                continue;
            }
<span class="nc" id="L113">        }</span>

<span class="nc" id="L115">        return variantList;</span>
    }

    /**
     * Checks whether a variant is valid.
     *
     * @param variant Variant object to be checked.
     * @return   true/false depending on whether 'variant' does contain valid values. Currently just a simple check of
     * reference/alternate attributes being strings of [A,C,G,T] of length &gt;= 0 is performed to detect cases such as
     * 19:13318673:(CAG)4:(CAG)5 which are not currently supported by CellBase. Ref and alt alleles must be different
     * as well for the variant to be valid. Functionality of the method may be improved in the future.
     */
    private boolean isValid(Variant variant) {
<span class="nc bnc" id="L128" title="All 2 branches missed.">        return (variant.getReference().matches(VARIANT_STRING_PATTERN)</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">                &amp;&amp; (variant.getAlternate().matches(VARIANT_STRING_PATTERN)</span>
<span class="nc bnc" id="L130" title="All 4 branches missed.">                  || variant.getAlternate().contains(&quot;[&quot;) || variant.getAlternate().contains(&quot;]&quot;)  // mated breakend</span>
<span class="nc bnc" id="L131" title="All 4 branches missed.">                  || variant.getAlternate().startsWith(&quot;.&quot;) || variant.getAlternate().endsWith(&quot;.&quot;)) // single breakend</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">                &amp;&amp; !variant.getAlternate().equals(variant.getReference()));</span>
    }

    public void post() {
<span class="nc bnc" id="L136" title="All 2 branches missed.">        for (VariantAnnotator variantAnnotator : variantAnnotatorList) {</span>
<span class="nc" id="L137">            variantAnnotator.close();</span>
<span class="nc" id="L138">        }</span>
<span class="nc" id="L139">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>